/* This is an autogenerated file from a template. Do not edit this file as it will be overwritten.*/
/**
 *
 * foc_params.h
 *
 * Field-oriented control parameters
 *
 * Component: FOC
 */ /*
 *
 * Motor Control Application Framework
 * R7/RC37 (commit 116330, build on 2023 Feb 09)
 *
 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
 * this software and any derivatives exclusively with Microchip products.
 *
 * This software and any accompanying information is for suggestion only.
 * It does not modify Microchip's standard warranty for its products.
 * You agree that you are solely responsible for testing the software and
 * determining its suitability.  Microchip has no obligation to modify,
 * test, certify, or support the software.
 *
 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
 * APPLICATION.
 *
 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
 * SOFTWARE.
 *
 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
 * THESE TERMS.
 *
 *
 ******************************************************************************/
#ifndef __FOC_PARAMS_H
#define __FOC_PARAMS_H

#include "sat_PI_params.h"
/* needed for speed controller output current */

#ifdef  __cplusplus
extern "C" {
#endif

//************** PI Coefficients **************
//// Current loop
// phase margin = 80 deg
// PI phase at crossover = 45.000 deg
// crossover frequency = 1.482 k rad/s (235.865 Hz)
/* Current loop proportional gain */
#define KIP                                  8333      // Q15(  0.25430) = +415.29552 mV/A        = +415.30386 mV/A        - 0.0020%
#define KIP_Q                                  15
/* Current loop integral gain */
#define KII                                   617      // Q15(  0.01883) = +614.99420 V/A/s       = +615.47221 V/A/s       - 0.0777%
#define KII_Q                                  15
//// Velocity loop
// phase margin = 65 deg
// PI phase at crossover = 10.000 deg
// crossover frequency = 93.135 rad/s (14.823 Hz)
/* Velocity loop proportional gain */
#define KWP                                 15401      // Q15(  0.47000) =  +35.84961 mA/(rad/s)  =  +35.85026 mA/(rad/s)  - 0.0018%
#define KWP_Q                                  15
/* Velocity loop integral gain */
#define KWI                                   253      // Q15(  0.00772) = +588.91969 mA/rad      = +588.73922 mA/rad      + 0.0307%
#define KWI_Q                                  15

//// Voltage loop (if applicable)
/* Voltage loop proportional gain */
#define MCAF_CONTROL_GAIN_KVP               14401      // Q15(  0.43948) = +269.11439 mA/V        = +269.10530 mA/V        + 0.0034%
#define MCAF_CONTROL_GAIN_KVP_Q                15
/* Voltage loop integral gain */
#define MCAF_CONTROL_GAIN_KVI                 144      // Q15(  0.00439) =   +2.69096 A/Vs        =   +2.69105 A/Vs        - 0.0036%
#define MCAF_CONTROL_GAIN_KVI_Q                15
/* Pole of voltage loop low-pass filter */
#define MCAF_FILTER_COEFF_VQ                 1638      // Q16(  0.02499) = +499.87793 rad/s       = +500.00000 rad/s       - 0.0244%
/* Gain from velocity reference to voltage */
#define MCAF_VELOCITY_TO_VOLTAGE_GAIN        9772      // Q15(  0.29822) =  +37.14709 mV/(rad/s)  =  +37.14689 mV/(rad/s)  + 0.0005%

/*
 * For the two output limits below, 
 * 1/sqrt(3) represents full line-to-line voltage applied to each
 * control loop's output.
 * Values above 1/sqrt(3) represent overmodulation, which introduces a tradeoff:
 * - higher values of overmodulation introduce control nonlinearity 
 *   and distortion including d-axis disturbances
 * - lower values of overmodulation are more linear with less distortion,
 *   but reduce voltage capability.
 *
 * Recommended Q-axis values are K/sqrt(3), 
 * where K is somewhere between 1.05 and 1.15
 */

// D-axis current control loop coefficients
#define     DKP        KIP
#define     DKI        KII
#define     DKC        Q15(0.99999)
/* Limit for output line-to-line voltage of d-axis current controller, expressed as a fraction of DC link voltage */
#define MCAF_CURRENT_CTRL_D_OUT_LIMIT       18919      // Q15(  0.57736) =   +1.00002 line-to-line =   +1.00000 line-to-line + 0.0020%
#define     DKNP       (15-KIP_Q)
#define     DKNI       (15-KII_Q)

// Q-axis current control loop coefficients
#define     QKP        KIP
#define     QKI        KII
#define     QKC        Q15(0.99999)
/* Limit for output line-to-line voltage of q-axis current controller, expressed as a fraction of DC link voltage */
#define MCAF_CURRENT_CTRL_Q_OUT_LIMIT       21756      // Q15(  0.66394) =   +1.14998 line-to-line =   +1.15000 line-to-line - 0.0019%
#define     QKNP       (15-KIP_Q)
#define     QKNI       (15-KII_Q)

// Velocity control loop coefficients
#define     WKP        KWP
#define     WKI        KWI
#define     WKC        Q15(0.0)
#define     MCAF_VELOCITY_CTRL_IQ_OUT_LIMIT  CURRENT_MAXIMUM_COMMAND   // see sat_PI_params.h for definition
#define     WKNP       (15-KWP_Q)
#define     WKNI       (15-KWI_Q)

/* Limits for magnitude and magnitude squared (Vd^2 + Vq^2) 
 * as output of PI current controllers, in terms of line-neutral voltage */
/* Limit for output magnitude of current controllers which triggers voltage saturation, expressed as a fraction of DC link voltage */
#define MCAF_CURRENT_CTRL_DQ_MAGNITUDE_LIMIT      17973      // Q15(  0.54849) = +950.01676 mline-to-line = +950.00000 mline-to-line + 0.0018%

/* ------ DC link voltage compensation ------ */
/*
 * Kr:                       3              log2 of dynamic range for DC link compensation
 * Q:                       12              binary point for reciprocal voltages
 * rV_U:                14.025 m1/V         normalization factor for reciprocal voltages
 * rVdcmax:            112.202 m1/V         reciprocal of maximum (fullscale) vdc
 * Vdcmin:               8.913  V           minimum DC link voltage for which we calculate reciprocals
 * rVdcmin:            112.199 m1/V         reciprocal of minimum DC link voltage
 *
 * The way that DC link voltage compensation is handled is to compute
 * a reciprocal factor motor.rVdc = Vdcmin/systemData.Vdc;
 * the current loops output a set of voltages which we transform into abc
 * coordinates and then compute duty cycles by multiplying by motor.rVdc using
 * an appropriate shift count MCAF_RVDC_Q.
 *
 * If the DC voltage systemData.Vdc is less than the minimum DC link voltage
 * MCAF_RVDC_MIN_VDC then we just clamp the reciprocal gain at maximum;
 * in this case the net gain from desired software voltage to actual delivered
 * voltage on the 3-phase bridge will be less than 1, but at that point the
 * voltage is low enough that we just want something numerically stable.
 *
 * We allow a dynamic range of 2^(Kr) : 1 (in other words 8:1 for Kr = 3)
 *
 * Example: Suppose our normalization factor for voltage is 52.8V, Kr = 3
 * and we have a Vdc value of 26.4V, with Vdcmin = 52.8 / (2^3) = 6.6V;
 * MCAF_RVDC_Q = 15 - Kr = 12.
 *
 * Then rVdc = Vdcmin / Vdc = 0.25 Q15 = 2.0 Q12.
 *
 * Desired voltages that are 0.5Q15 (=0.5 * 52.8V = 26.4V) 
 * will get multiplied by rVdc 
 * and turned into a unitless duty cycle of 0.5 * 2.0 = 1.0;
 * when applied to a PWM half-bridge with Vdc = 26.4V we will get the
 * voltage we expect.
 *
 * As the voltage Vdc rises or falls, rVdc changes inversely to compensate.
 *
 * If changed by hand, MCAF_RVDC_MIN_VDC should be equal to 1.0 Q(MCAF_RVDC_Q).
 * Values of Kr = 3 or Kr = 4 are suggested (8:1 or 16:1 fullscale range),
 * making MCAF_RVDC_Q either 12 or 11.
 */

/* binary point for reciprocal voltages */
#define MCAF_RVDC_Q                            12
/* minimum DC link voltage for which we calculate reciprocals */
#define MCAF_RVDC_MIN_VDC                    4096      // Q15(  0.12500) =   +8.91250 V           =   +8.91277 V           - 0.0031%
/* reciprocal of minimum DC link voltage */
#define MCAF_RVDC_MIN                       32767      // Q12(  7.99976) = +112.19854 m1/V        = +112.19854 m1/V        + 0.0000%

#define MCAF_DEAD_TIME_COMPENSATION_VOLTAGE_DELAY          0

#define MCAF_RECIPROCAL_CURRENT_NUMERATOR (1<<11) // 1.0 Q11

#ifdef  __cplusplus
}
#endif

#endif // __FOC_PARAMS_H
