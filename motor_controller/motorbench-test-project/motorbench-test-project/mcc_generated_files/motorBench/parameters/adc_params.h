/* This is an autogenerated file from a template. Do not edit this file as it will be overwritten.*/
/**
 *
 * adc_params.h
 *
 * ADC parameters
 *
 * Component: ADC compensation
 */ /*
 *
 * Motor Control Application Framework
 * R7/RC37 (commit 116330, build on 2023 Feb 09)
 *
 * (c) 2017 - 2023 Microchip Technology Inc. and its subsidiaries. You may use
 * this software and any derivatives exclusively with Microchip products.
 *
 * This software and any accompanying information is for suggestion only.
 * It does not modify Microchip's standard warranty for its products.
 * You agree that you are solely responsible for testing the software and
 * determining its suitability.  Microchip has no obligation to modify,
 * test, certify, or support the software.
 *
 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS".  NO WARRANTIES,
 * WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE,
 * INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY,
 * AND FITNESS FOR A PARTICULAR PURPOSE, OR ITS INTERACTION WITH
 * MICROCHIP PRODUCTS, COMBINATION WITH ANY OTHER PRODUCTS, OR USE IN ANY
 * APPLICATION.
 *
 * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL,
 * PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF
 * ANY KIND WHATSOEVER RELATED TO THE USE OF THIS SOFTWARE, THE
 * motorBench(R) DEVELOPMENT SUITE TOOL, PARAMETERS AND GENERATED CODE,
 * HOWEVER CAUSED, BY END USERS, WHETHER MICROCHIP'S CUSTOMERS OR
 * CUSTOMER'S CUSTOMERS, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES OR THE DAMAGES ARE FORESEEABLE. TO THE
 * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
 * CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
 * OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
 * SOFTWARE.
 *
 * MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF
 * THESE TERMS.
 *
 *
 ******************************************************************************/
#ifndef __ADC_PARAMS_H
#define __ADC_PARAMS_H

#ifdef  __cplusplus
extern "C" {
#endif

/* ------------------ ADC coefficients ------------------ */

/* See architectural notes on ADC offset calibration. Quick summary:
 *
 * SHIFT and RANGE are chosen to guarantee that the range of ADC offset
 * lies within +/- RANGE, so that large ADC offsets are avoided,
 * and large spurious values of raw ADC inputs outside +/- RANGE are ignored.
 * 
 * FILTER_GAIN is a Q16 value that specifies the effective lowpass filter time 
 * constant, which depends on FILTER_GAIN and the gain from ADC readings
 * to compensated measurement. More specifically, the product P of FILTER_GAIN
 * and the ADC gain equals the timestep divided by the filter time constant.
 * Example: FILTER_GAIN = -16384 = -0.25 Q16, ADC gain = -0.5 Q15.
 * Then P = -0.25 * -0.5 = 0.125, and we have a filter time constant
 * of 1/0.125 = 8 timesteps.
 *
 * COUNT specifies the number of ADC timesteps used for ADC calibration.
 * Continuing the example above, if we have COUNT = 128 then this is
 * 16 time constants which is plenty of time for the ADC calibration
 * to stabilize. A minimum of 9 time constants is recommended, which allows
 * an ideal settling time of 99.99% towards the equilibrium value, plenty
 * of margin to allow for quantization errors.
 */
    
/* normalized range of current offset compensation, relative to ADC fullscale */
#define MCAF_CAL_RANGE                       1024      // Q15(  0.03125) =  +31.25000 m           =  +31.25000 m           + 0.0000%
/* shift count used to limit offset to 2^(-MCAF_CAL_SHIFT) of ADC fullscale */
#define MCAF_CAL_SHIFT                          5
/* number of samples taken for current offset compensation */
#define MCAF_CAL_COUNT                        128
/* low-pass filter gain for current offset compensation */
#define MCAF_CAL_FILTER_GAIN                16384      // Q16(  0.25000) = +250.00000 m           = +250.00000 m           + 0.0000%


//************** ADC Scaling **************
// Scaling constants: Determined by calibration or hardware design. 
#define     DQKA_NOMINAL (1<<14)

/*
 * Current compensation gains
 *
 * Ia = KAA*Ia_measured + KAB*Ib_measured
 * Ib = KBA*Ia_measured + KBB*Ib_measured
 *
 * Ic = KCC*Ic_measured (if applicable)
 *
 */
/* normalized A->A current gain */
#define CURRENT_KAA                         16384      // Q14(  1.00000) =   +1.00000             =   +1.00000             + 0.0000%   
/* normalized B->A current gain */
#define CURRENT_KAB                             0      // Q14(  0.00000) =   +0.00000             =   +0.00000             + 0.0000%   
/* normalized A->B current gain */
#define CURRENT_KBA                             0      // Q14(  0.00000) =   +0.00000             =   +0.00000             + 0.0000%   
/* normalized B->B current gain */
#define CURRENT_KBB                         16384      // Q14(  1.00000) =   +1.00000             =   +1.00000             + 0.0000%
/* normalized C->C current gain */
#define CURRENT_KCC                         16384      // Q14(  1.00000) =   +1.00000             =   +1.00000             + 0.0000%
/* scaling for Idc */
#define MCAF_IDC_SCALING_FACTOR             16384      // Q14(  1.00000) =   +1.00000             =   +1.00000             + 0.0000%

/* scaling for Vdc */
#define MCAF_VDC_SCALING_FACTOR              1024      // Q10(  1.00000) =   +1.00000             =   +1.00000             + 0.0000%
#define MCAF_VDC_SCALING_FACTOR_Q              10

/** Is the DC link voltage reading scaled? 
 * @return true if DC link voltage reading has a scaling factor applied
 */
inline static bool MCAF_ADCIsVdcScaled(void)
{
    return false;
}

/** Is phase A current measurement inverted?
 * @return true if increased current out of the phase A terminal produces a lower ADC reading 
 */
inline static bool MCAF_ADCIsPhaseACurrentInverted(void)
{
    return true;
}

/** Is phase B current measurement inverted?
 * @return true if increased current out of the phase B terminal produces a lower ADC reading 
 */
inline static bool MCAF_ADCIsPhaseBCurrentInverted(void)
{
    return true;
}

/** Is phase C current measurement inverted?
 * @return true if increased current out of the phase C terminal produces a lower ADC reading 
 */
inline static bool MCAF_ADCIsPhaseCCurrentInverted(void)
{
    return true;
}

/** Is dc bus current measurement inverted?
 * @return true if increased current out of the bridge terminals produces a lower ADC reading 
 */
inline static bool MCAF_ADCIsDCLinkCurrentInverted(void)
{
    return false;
}

/* temperature gain */
#define MCAF_BRIDGE_TEMPERATURE_GAIN        33000      // Q16(  0.50354) = +503.54004 m           = +503.54000 m           + 0.0000%
#define MCAF_BRIDGE_TEMPERATURE_OFFSET            5000 //            temperature offset
/* Pole of bridge temperature low-pass filter */
#define MCAF_BRIDGE_TEMPERATURE_FILTER_GAIN        328      // Q16(  0.00500) = +100.09766 rad/s       = +100.00000 rad/s       + 0.0977%
/* Maximum temperature slew rate */
#define MCAF_BRIDGE_TEMPERATURE_SLEW_RATE       1311      // Q15(  0.04001) =   +4.00085 C/s         =   +4.00000 C/s         + 0.0214%

#ifdef  __cplusplus
}
#endif

#endif // __ADC_PARAMS_H
